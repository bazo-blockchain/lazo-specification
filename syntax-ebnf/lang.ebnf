VersionDirective = "version" Integer "." Integer;
Contract = "contract" Identifier [ "is" Identifier { "," Identifier} ] "{" { ContractParts } "}";
ContractParts = { VariableDeclaration | Function | Struct | Event | Enum };
Interface = "interface" Identifier "{" InterfaceParts "}";
InterfaceParts = { FunctionHead };
Constructor = "constructor" "(" ParameterList ")" StatementBlock;
Annotation = "[" Identifier [ "=" Identifier | Expression ] "]";
EmitStatement = "emit" EventCall;
EventCall = Identifier "(" ArgumentList ")";
Event = "event" Identifier "(" ParameterList ")";
VariableDeclaration = [ "internal" ] [ "readonly" ] Type Identifier [ "=" Expression ]";";
Function = FunctionHead FunctionBody;
FunctionHead = [ "internal" ] "function" Type Identifier "(" ParameterList ")";
Struct = "struct" Identifier "{" VariableDeclaration { "," VariableDeclaration} "}";
ParameterList = [ Parameter {"," Parameter}];
Parameter = Type Identifier [ "=" Expression];
FunctionBody = StatementBlock;
Type = Identifier | ArrayType;
ArrayType = Type "[" "]";
Enum = "enum" Identifier "{" EnumValue {"," EnumValue} "}";
EnumValue = Identifier;
StatementBlock = "{" { Statement } "}";
Statement = ";" | VariableDeclaration | Assignment | IfStatement | WhileStatement | CallStatement | ReturnStatement;
Assignment = Designator "=" ( Expression | TernaryExpression ) ";";
IfStatement = "if" "(" Expression ")" StatementBlock [ "else if" "(" Expression ")" StatementBlock ] [ "else" StatementBlock ];
ForStatement = "for" "(" Identifier ":" RangeStatement ")" StatementBlock;
ForEachStatement = "foreach" "(" ")";
MapForEach = "foreach" "(" [[Type] Identifier ","] Type Identifier ":" IterableDesignator")" StatementBlock;
RangeStatement = "range" "(" ArgumentList ")";
CallStatement = FunctionCall ";";
ReturnStatement = "return" Expression { "," Expression } ;
TernaryExpression = Expression "?" Statement ":" Statement ";";
Expression = { "||" LogicTerm };
LogicTerm = LogicFactor { "&&" LogicFactor };
LogicFactor = BitwiseOrExpression "|" BitwiseOrExpression;
BitwiseOrExpression = BitwiseXOrExpression "^" BitwiseXOrExpression;
BitwiseXorExpression = BitwiseAndExpression "&" BitwiseAndExpression;
BitwiseAndExpression = EqualityExpression { ( "!=" | "==" ) EqualityExpression };
EqualityExpression = ComparisonExpression { ( "<" | "<=" | ">" | ">=" ) ComparisonExpression };
ComparisonExpression = BitwiseShiftExpression ( "<<" | ">>" ) BitwiseShiftOperator;
BitwiseShiftExpression = Term {("+" | "-" ) Term};
Term = Factor { ( "*" | "/" | "%" ) Factor };
Factor = Exponent {( "**" ) Exponent};
Exponent = "(" Type ")" CastExpression;
CastExpression = PrefixExpression | UnaryExpression;
PrefixExpression = ( "++" | "--" ) CallExpression;
UnaryExpression = ( "!" | "+" | "-" | "âˆ¼" ) ( CallExpression | PostfixExpression );
CallExpression = Operand | "(" Expression ")";
PostfixExpression = CallExpression ( "++" | "--" );
Operand = Literal | Designator | MapCreation | ArrayCreation | FunctionCall;
Literal = Integer | Address | Character | String | Bool ;
IterableDesignator = Identifier | Designator "." Identifier;
Designator = Identifier | Designator "." Identifier | Designator "[" Expression "]";
ExceptionDeclaration = "exception" Identifier "{" VariableDeclaration { "," VariableDeclaration} "}";
ExceptionCreation = Identifier "(" ArgumentList ")" ;
MapCreation = "new" "Map" "<"Type "," Type ">" "(" ")";
ArrayCreation = "new" Identifier "[" Expression "]";
FunctionCall = Designator "(" ArgumentList ")";
ArgumentList = [ Expression { "," Expression }];
Identifier = Letter { Letter | Digit };
Throw = "throw" ExceptionCreation;
Continue = "continue";
Break = "break";
Catch = "catch" Identifier Identifier StatementBlock;
Address = "0x" { HexDigit };
Integer = Digit { Digit };
Character = "'" CharCode "'";
Bool = "false" | "true";
String = """ { CharCode } """;
Letter = "A" .. "Z" | "a" .. "z";
Digit = "0" .. "9";
HexDigit = Digit | "a" .. "f";
CharCode = any character except ' in Character and except " in String.;